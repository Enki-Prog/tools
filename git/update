#! /usr/bin/perl -w

# Hook for checking the log format given to git.
# Written by Thomas "Enki" Badie <badie@lrde.epita.fr>

# This hook prevents push containing invalid logs to be pushed on the
# server.

# To add a check, find a spot in "check_log_style", and add your own
# chunk. You have to add your errors to @errors. The format is the
# message without a newline at the end.

use strict;

# The classical argv[0], without the relative path.
(my $ME = $0) =~ s|.*/||;

# The list of ignored files... Add your own here.
my @IGNORED_FILES = qw/ChangeLog .gitignore NEWS THANKS/;


# Internal global.
our %g_IGNORED_FILES;
my $nb_error = 0;
my $warning = 0;

# I found the way to initialize an array more user-friendly than
# a hash table. So the user have to fill an array, and I translate
# it into a hash to be quicker.
sub init
{
  foreach (@IGNORED_FILES)
  {
    $g_IGNORED_FILES{$_} = "t";
  }
}


sub print_usage()
{
  print "usage:\n$ME <ref> <oldrev> <newrev>\n";
}


## The function which contains all the style check.
## String which is the concatenation of all the file.
## Receive the log message in raw.
## The SHA1 of the commit.
sub check_log_style($$$)
{
  my ($list, $message, $sha) = @_;

  # In this hash table, we'll add all the modified files,
  # and we do not add the files like "ChangeLog" etc...
  # The list of these files is the global variable
  # @IGNORED_FILES
  my @files;

  foreach (split ' ', $list)
  {
    my $long_name = $_;
    s|.*/||;
    push @files, $long_name
        unless defined $g_IGNORED_FILES{$_};
  }

  # In the case of only commit a ignored file.
  return 0 unless @files ;

  # Will contain all error messages.
  my @error;

  # In this loop, we check that the file is written in the log
  # message.
  # We can check it better by checking only in the part
  # "* ...... :" in the message, but maybe it is too much.
  foreach (@files)
  {
    if ($message !~ /$_/)
    {
      push @error, "`$_' is not mentioned in commit message.";
    }
  }


  # Now we check if there is a first-line summary.
  #
  # Any commit of more than one line should have a one-line summary.
  # We reuse the trick used in vc-dwim: if the first line starts with
  # a star, it means there is no one-line summary.
  my @lines = split(/\n/, $message);
  push @error, "Missing one-line summary."
    if ($#lines > 0) && ($message =~ /^[\s\n]*\* /);

  # Now we check the style of the "* file (func):". The way we choose is
  # to check if we have:
  # "* file desc whatever
  # *"
  # And in this case, we check if we don't have a semicolon between
  # the two.
  push @error, "Missing `:' between two entries."
      if ($message =~ /\s*\*[^:]+.+\n\s*\*/m
          and $message !~ /\s*\*[^:]+:.+\n\s*\*/m);

  push @error, "Line exceeds 72 characters."
      if $message =~ /^.{73,}$/m;


  # Check if the format "* file:" is checked. Only a little test
  # because we do not want to have false positive.
  # The regexp we check is a star as first character of a line.
  push @error, "No entry found in commit message."
      if $message !~ /^\s*\*/m;


  push @error, "No space before colon in English."
      if $message =~ /\s:/;

  # SPOT !
  push @error, "accepting -> acceptance."
      if $message =~ /\baccepting\s+cond/im;


  # Print the results of the check.
  print STDERR "* Invalid message for commit $sha:\n" if ($#error + 1);

  $message =~ s/^/| /gm;
  print STDERR $message;

  foreach (@error)
  {
    print STDERR "** $_\n";
  }

  $nb_error += $#error + 1;
}



# Get the information from the command line.
my $refname = $ARGV[0];
my $oldrev = $ARGV[1];
my $newrev = $ARGV[2];


# The main get the list of commit and call the checker for each
# commit.
sub main
{
  if (not defined $refname
      || not defined $oldrev
      || not defined $newrev)
  {
    print_usage;
    exit 1;
  }

  # 80 columns :)
  my $zero="0000000000000000000000000000000000000000";

  # It is a branch deletion. Nothing to say about this.
  if ($newrev eq $zero)
  {
    return 0;
  }

  # We want the name of the branch.
  (my $branch = $refname) =~ s+refs/heads/++;


  # Here, we decide if which branch we'll check.
  $warning = 1 if $branch =~ m#/#
      and $branch !~ m/candidates/;

  # Will contain all the sha1 of the commits which must be checked.
  my @commits;

  my $revspec = undef;

  $revspec = "$newrev" if $oldrev eq $zero;
  $revspec = "$oldrev..$newrev" if not defined $revspec;

  my $other_branches =
      `git for-each-ref --format='%(refname)' refs/heads |
        grep -F -x -v $refname | grep -x 'refs/heads/\\(candidates/.*\\|[^/]*\\)'`;

  # Other branches is a list of branches if the format:
  # "branch\nbranch\n". But it makes the next call fail because of
  # parse error. So We remove the newline.
  $other_branches =~ y/\n/ /;

  my $new_revisions=`git rev-parse --not $other_branches |
    git rev-list --stdin $revspec`;

  @commits = split '\n', $new_revisions;

  foreach (@commits)
  {
    chomp;

    # Get the list of modified files.
    # "git show commit" shows the log and the changed file.
    # --pretty="format:" makes the log print nothing. So I get the
    # changed file! :)
    my $fileList = `git show --pretty="format:" --name-only $_`;
    $fileList =~ tr/\n/ /;

    # Get the commit log. Without the header.
    my $commitLog = `git log -1 --pretty=format:%B $_`;

    # Apply the checks on the commit.
    check_log_style($fileList, $commitLog, $_);
  }
}

# Initialize the hash map of file ignore. Better complexity to find
# if an element in present.
init();
main();

exit 1 if $nb_error and $warning == 0;
